"use strict";

// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
import nativeModule from "./proofport-ffi.js";
import { AbstractFfiConverterByteArray, FfiConverterArray, FfiConverterArrayBuffer, FfiConverterBool, FfiConverterInt32, FfiConverterMap, FfiConverterOptional, FfiConverterUInt32, UniffiError, UniffiInternalError, UniffiRustCaller, uniffiCreateFfiConverterString, uniffiCreateRecord, uniffiTypeNameSymbol } from "uniffi-bindgen-react-native";

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({
  code: 0
}));
const uniffiIsDebug =
// @ts-ignore -- The process global might not be defined
typeof process !== "object" ||
// @ts-ignore -- The process global might not be defined
process?.env?.NODE_ENV !== "production" || false;
// Public interface members begin here.

/**
 * Combine proof and public inputs back into a single proof
 * Used when you need to reconstruct the combined format
 */
export function combineProofAndPublicInputs(proof, publicInputs) {
  return FfiConverterArrayBuffer.lift(uniffiCaller.rustCall(/*caller:*/callStatus => {
    return nativeModule().ubrn_uniffi_proofport_fn_func_combine_proof_and_public_inputs(FfiConverterArrayBuffer.lower(proof), FfiConverterArrayArrayBuffer.lower(publicInputs), callStatus);
  }, /*liftString:*/FfiConverterString.lift));
}
export function generateCircomProof(zkeyPath, circuitInputs, proofLib) /*throws*/{
  return FfiConverterTypeCircomProofResult.lift(uniffiCaller.rustCallWithError(/*liftError:*/FfiConverterTypeMoproError.lift.bind(FfiConverterTypeMoproError), /*caller:*/callStatus => {
    return nativeModule().ubrn_uniffi_proofport_fn_func_generate_circom_proof(FfiConverterString.lower(zkeyPath), FfiConverterString.lower(circuitInputs), FfiConverterTypeProofLib.lower(proofLib), callStatus);
  }, /*liftString:*/FfiConverterString.lift));
}
export function generateHalo2Proof(srsPath, pkPath, circuitInputs) /*throws*/{
  return FfiConverterTypeHalo2ProofResult.lift(uniffiCaller.rustCallWithError(/*liftError:*/FfiConverterTypeMoproError.lift.bind(FfiConverterTypeMoproError), /*caller:*/callStatus => {
    return nativeModule().ubrn_uniffi_proofport_fn_func_generate_halo2_proof(FfiConverterString.lower(srsPath), FfiConverterString.lower(pkPath), FfiConverterMapStringArrayString.lower(circuitInputs), callStatus);
  }, /*liftString:*/FfiConverterString.lift));
}
/**
 * Generates a Noir proof with automatic hash function selection
 *
 * This is the main proof generation function that automatically chooses
 * the appropriate hash function based on the intended use case:
 *
 * - `on_chain = true`: Uses Keccak hash for Solidity verifier compatibility
 * - `on_chain = false`: Uses Poseidon hash for better performance
 */
export function generateNoirProof(circuitPath, srsPath, inputs, onChain, vk, lowMemoryMode) /*throws*/{
  return FfiConverterArrayBuffer.lift(uniffiCaller.rustCallWithError(/*liftError:*/FfiConverterTypeMoproError.lift.bind(FfiConverterTypeMoproError), /*caller:*/callStatus => {
    return nativeModule().ubrn_uniffi_proofport_fn_func_generate_noir_proof(FfiConverterString.lower(circuitPath), FfiConverterOptionalString.lower(srsPath), FfiConverterArrayString.lower(inputs), FfiConverterBool.lower(onChain), FfiConverterArrayBuffer.lower(vk), FfiConverterBool.lower(lowMemoryMode), callStatus);
  }, /*liftString:*/FfiConverterString.lift));
}
/**
 * Generates a verification key with automatic hash function selection
 *
 * This function automatically chooses the appropriate hash function based
 * on the intended use case:
 *
 * - `on_chain = true`: Uses Keccak hash for Solidity verifier compatibility
 * - `on_chain = false`: Uses Poseidon hash fotr better performance
 */
export function getNoirVerificationKey(circuitPath, srsPath, onChain, lowMemoryMode) /*throws*/{
  return FfiConverterArrayBuffer.lift(uniffiCaller.rustCallWithError(/*liftError:*/FfiConverterTypeMoproError.lift.bind(FfiConverterTypeMoproError), /*caller:*/callStatus => {
    return nativeModule().ubrn_uniffi_proofport_fn_func_get_noir_verification_key(FfiConverterString.lower(circuitPath), FfiConverterOptionalString.lower(srsPath), FfiConverterBool.lower(onChain), FfiConverterBool.lower(lowMemoryMode), callStatus);
  }, /*liftString:*/FfiConverterString.lift));
}
/**
 * Get the number of public inputs from a circuit's JSON manifest
 * This reads the circuit bytecode and extracts the public parameter count
 */
export function getNumPublicInputsFromCircuit(circuitPath) {
  return FfiConverterUInt32.lift(uniffiCaller.rustCall(/*caller:*/callStatus => {
    return nativeModule().ubrn_uniffi_proofport_fn_func_get_num_public_inputs_from_circuit(FfiConverterString.lower(circuitPath), callStatus);
  }, /*liftString:*/FfiConverterString.lift));
}
/**
 * You can also customize the bindings by #[uniffi::export]
 * Reference: https://mozilla.github.io/uniffi-rs/latest/proc_macro/index.html
 */
export function moproHelloWorld() {
  return FfiConverterString.lift(uniffiCaller.rustCall(/*caller:*/callStatus => {
    return nativeModule().ubrn_uniffi_proofport_fn_func_mopro_hello_world(callStatus);
  }, /*liftString:*/FfiConverterString.lift));
}
/**
 * Parse a combined proof (proof + public inputs) into separated components
 * The mopro proof format has public inputs prepended to the proof bytes
 * This function separates them for on-chain verification
 */
export function parseProofWithPublicInputs(proof, numPublicInputs) {
  return FfiConverterTypeProofWithPublicInputs.lift(uniffiCaller.rustCall(/*caller:*/callStatus => {
    return nativeModule().ubrn_uniffi_proofport_fn_func_parse_proof_with_public_inputs(FfiConverterArrayBuffer.lower(proof), FfiConverterUInt32.lower(numPublicInputs), callStatus);
  }, /*liftString:*/FfiConverterString.lift));
}
export function verifyCircomProof(zkeyPath, proofResult, proofLib) /*throws*/{
  return FfiConverterBool.lift(uniffiCaller.rustCallWithError(/*liftError:*/FfiConverterTypeMoproError.lift.bind(FfiConverterTypeMoproError), /*caller:*/callStatus => {
    return nativeModule().ubrn_uniffi_proofport_fn_func_verify_circom_proof(FfiConverterString.lower(zkeyPath), FfiConverterTypeCircomProofResult.lower(proofResult), FfiConverterTypeProofLib.lower(proofLib), callStatus);
  }, /*liftString:*/FfiConverterString.lift));
}
export function verifyHalo2Proof(srsPath, vkPath, proof, publicInput) /*throws*/{
  return FfiConverterBool.lift(uniffiCaller.rustCallWithError(/*liftError:*/FfiConverterTypeMoproError.lift.bind(FfiConverterTypeMoproError), /*caller:*/callStatus => {
    return nativeModule().ubrn_uniffi_proofport_fn_func_verify_halo2_proof(FfiConverterString.lower(srsPath), FfiConverterString.lower(vkPath), FfiConverterArrayBuffer.lower(proof), FfiConverterArrayBuffer.lower(publicInput), callStatus);
  }, /*liftString:*/FfiConverterString.lift));
}
/**
 * Verifies a Noir proof with automatic hash function selection
 *
 * This function automatically uses the correct verification method based
 * on how the proof was generated:
 *
 * - `on_chain = true`: Verifies Keccak-based proof (Solidity compatible)
 * - `on_chain = false`: Verifies Poseidon-based proof (performance optimized)
 */
export function verifyNoirProof(circuitPath, proof, onChain, vk, lowMemoryMode) /*throws*/{
  return FfiConverterBool.lift(uniffiCaller.rustCallWithError(/*liftError:*/FfiConverterTypeMoproError.lift.bind(FfiConverterTypeMoproError), /*caller:*/callStatus => {
    return nativeModule().ubrn_uniffi_proofport_fn_func_verify_noir_proof(FfiConverterString.lower(circuitPath), FfiConverterArrayBuffer.lower(proof), FfiConverterBool.lower(onChain), FfiConverterArrayBuffer.lower(vk), FfiConverterBool.lower(lowMemoryMode), callStatus);
  }, /*liftString:*/FfiConverterString.lift));
}
/**
 * Generated factory for {@link CircomProof} record objects.
 */
export const CircomProof = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CircomProof}, with defaults specified
     * in Rust, in the {@link proofport} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link CircomProof}, with defaults specified
     * in Rust, in the {@link proofport} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link proofport} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeCircomProof = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        a: FfiConverterTypeG1.read(from),
        b: FfiConverterTypeG2.read(from),
        c: FfiConverterTypeG1.read(from),
        protocol: FfiConverterString.read(from),
        curve: FfiConverterString.read(from)
      };
    }
    write(value, into) {
      FfiConverterTypeG1.write(value.a, into);
      FfiConverterTypeG2.write(value.b, into);
      FfiConverterTypeG1.write(value.c, into);
      FfiConverterString.write(value.protocol, into);
      FfiConverterString.write(value.curve, into);
    }
    allocationSize(value) {
      return FfiConverterTypeG1.allocationSize(value.a) + FfiConverterTypeG2.allocationSize(value.b) + FfiConverterTypeG1.allocationSize(value.c) + FfiConverterString.allocationSize(value.protocol) + FfiConverterString.allocationSize(value.curve);
    }
  }
  ;
  return new FFIConverter();
})();
/**
 * Generated factory for {@link CircomProofResult} record objects.
 */
export const CircomProofResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CircomProofResult}, with defaults specified
     * in Rust, in the {@link proofport} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link CircomProofResult}, with defaults specified
     * in Rust, in the {@link proofport} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link proofport} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeCircomProofResult = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        proof: FfiConverterTypeCircomProof.read(from),
        inputs: FfiConverterArrayString.read(from)
      };
    }
    write(value, into) {
      FfiConverterTypeCircomProof.write(value.proof, into);
      FfiConverterArrayString.write(value.inputs, into);
    }
    allocationSize(value) {
      return FfiConverterTypeCircomProof.allocationSize(value.proof) + FfiConverterArrayString.allocationSize(value.inputs);
    }
  }
  ;
  return new FFIConverter();
})();
/**
 * Generated factory for {@link G1} record objects.
 */
export const G1 = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link G1}, with defaults specified
     * in Rust, in the {@link proofport} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link G1}, with defaults specified
     * in Rust, in the {@link proofport} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link proofport} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeG1 = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        x: FfiConverterString.read(from),
        y: FfiConverterString.read(from),
        z: FfiConverterString.read(from)
      };
    }
    write(value, into) {
      FfiConverterString.write(value.x, into);
      FfiConverterString.write(value.y, into);
      FfiConverterString.write(value.z, into);
    }
    allocationSize(value) {
      return FfiConverterString.allocationSize(value.x) + FfiConverterString.allocationSize(value.y) + FfiConverterString.allocationSize(value.z);
    }
  }
  ;
  return new FFIConverter();
})();
/**
 * Generated factory for {@link G2} record objects.
 */
export const G2 = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link G2}, with defaults specified
     * in Rust, in the {@link proofport} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link G2}, with defaults specified
     * in Rust, in the {@link proofport} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link proofport} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeG2 = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        x: FfiConverterArrayString.read(from),
        y: FfiConverterArrayString.read(from),
        z: FfiConverterArrayString.read(from)
      };
    }
    write(value, into) {
      FfiConverterArrayString.write(value.x, into);
      FfiConverterArrayString.write(value.y, into);
      FfiConverterArrayString.write(value.z, into);
    }
    allocationSize(value) {
      return FfiConverterArrayString.allocationSize(value.x) + FfiConverterArrayString.allocationSize(value.y) + FfiConverterArrayString.allocationSize(value.z);
    }
  }
  ;
  return new FFIConverter();
})();
/**
 * Generated factory for {@link Halo2ProofResult} record objects.
 */
export const Halo2ProofResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Halo2ProofResult}, with defaults specified
     * in Rust, in the {@link proofport} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link Halo2ProofResult}, with defaults specified
     * in Rust, in the {@link proofport} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link proofport} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeHalo2ProofResult = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        proof: FfiConverterArrayBuffer.read(from),
        inputs: FfiConverterArrayBuffer.read(from)
      };
    }
    write(value, into) {
      FfiConverterArrayBuffer.write(value.proof, into);
      FfiConverterArrayBuffer.write(value.inputs, into);
    }
    allocationSize(value) {
      return FfiConverterArrayBuffer.allocationSize(value.proof) + FfiConverterArrayBuffer.allocationSize(value.inputs);
    }
  }
  ;
  return new FFIConverter();
})();

/**
 * Struct representing a proof with separated public inputs
 * Used for on-chain verification where proof and public inputs are passed separately
 */

/**
 * Generated factory for {@link ProofWithPublicInputs} record objects.
 */
export const ProofWithPublicInputs = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ProofWithPublicInputs}, with defaults specified
     * in Rust, in the {@link proofport} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link ProofWithPublicInputs}, with defaults specified
     * in Rust, in the {@link proofport} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link proofport} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeProofWithPublicInputs = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        proof: FfiConverterArrayBuffer.read(from),
        publicInputs: FfiConverterArrayArrayBuffer.read(from),
        numPublicInputs: FfiConverterUInt32.read(from)
      };
    }
    write(value, into) {
      FfiConverterArrayBuffer.write(value.proof, into);
      FfiConverterArrayArrayBuffer.write(value.publicInputs, into);
      FfiConverterUInt32.write(value.numPublicInputs, into);
    }
    allocationSize(value) {
      return FfiConverterArrayBuffer.allocationSize(value.proof) + FfiConverterArrayArrayBuffer.allocationSize(value.publicInputs) + FfiConverterUInt32.allocationSize(value.numPublicInputs);
    }
  }
  ;
  return new FFIConverter();
})();
const stringConverter = {
  stringToBytes: s => uniffiCaller.rustCall(status => nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(s, status)),
  bytesToString: ab => uniffiCaller.rustCall(status => nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(ab, status)),
  stringByteLength: s => uniffiCaller.rustCall(status => nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(s, status))
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Error type: MoproError

// Enum: MoproError
export let MoproError_Tags = /*#__PURE__*/function (MoproError_Tags) {
  MoproError_Tags["CircomError"] = "CircomError";
  MoproError_Tags["Halo2Error"] = "Halo2Error";
  MoproError_Tags["NoirError"] = "NoirError";
  return MoproError_Tags;
}({});
export const MoproError = (() => {
  class CircomError_ extends UniffiError {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    [uniffiTypeNameSymbol] = "MoproError";
    tag = MoproError_Tags.CircomError;
    constructor(v0) {
      super("MoproError", "CircomError");
      this.inner = Object.freeze([v0]);
    }
    static new(v0) {
      return new CircomError_(v0);
    }
    static instanceOf(obj) {
      return obj.tag === MoproError_Tags.CircomError;
    }
    static hasInner(obj) {
      return CircomError_.instanceOf(obj);
    }
    static getInner(obj) {
      return obj.inner;
    }
  }
  class Halo2Error_ extends UniffiError {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    [uniffiTypeNameSymbol] = "MoproError";
    tag = MoproError_Tags.Halo2Error;
    constructor(v0) {
      super("MoproError", "Halo2Error");
      this.inner = Object.freeze([v0]);
    }
    static new(v0) {
      return new Halo2Error_(v0);
    }
    static instanceOf(obj) {
      return obj.tag === MoproError_Tags.Halo2Error;
    }
    static hasInner(obj) {
      return Halo2Error_.instanceOf(obj);
    }
    static getInner(obj) {
      return obj.inner;
    }
  }
  class NoirError_ extends UniffiError {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    [uniffiTypeNameSymbol] = "MoproError";
    tag = MoproError_Tags.NoirError;
    constructor(v0) {
      super("MoproError", "NoirError");
      this.inner = Object.freeze([v0]);
    }
    static new(v0) {
      return new NoirError_(v0);
    }
    static instanceOf(obj) {
      return obj.tag === MoproError_Tags.NoirError;
    }
    static hasInner(obj) {
      return NoirError_.instanceOf(obj);
    }
    static getInner(obj) {
      return obj.inner;
    }
  }
  function instanceOf(obj) {
    return obj[uniffiTypeNameSymbol] === "MoproError";
  }
  return Object.freeze({
    instanceOf,
    CircomError: CircomError_,
    Halo2Error: Halo2Error_,
    NoirError: NoirError_
  });
})();
// FfiConverter for enum MoproError
const FfiConverterTypeMoproError = (() => {
  const ordinalConverter = FfiConverterInt32;
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new MoproError.CircomError(FfiConverterString.read(from));
        case 2:
          return new MoproError.Halo2Error(FfiConverterString.read(from));
        case 3:
          return new MoproError.NoirError(FfiConverterString.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value, into) {
      switch (value.tag) {
        case MoproError_Tags.CircomError:
          {
            ordinalConverter.write(1, into);
            const inner = value.inner;
            FfiConverterString.write(inner[0], into);
            return;
          }
        case MoproError_Tags.Halo2Error:
          {
            ordinalConverter.write(2, into);
            const inner = value.inner;
            FfiConverterString.write(inner[0], into);
            return;
          }
        case MoproError_Tags.NoirError:
          {
            ordinalConverter.write(3, into);
            const inner = value.inner;
            FfiConverterString.write(inner[0], into);
            return;
          }
        default:
          // Throwing from here means that MoproError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value) {
      switch (value.tag) {
        case MoproError_Tags.CircomError:
          {
            const inner = value.inner;
            let size = ordinalConverter.allocationSize(1);
            size += FfiConverterString.allocationSize(inner[0]);
            return size;
          }
        case MoproError_Tags.Halo2Error:
          {
            const inner = value.inner;
            let size = ordinalConverter.allocationSize(2);
            size += FfiConverterString.allocationSize(inner[0]);
            return size;
          }
        case MoproError_Tags.NoirError:
          {
            const inner = value.inner;
            let size = ordinalConverter.allocationSize(3);
            size += FfiConverterString.allocationSize(inner[0]);
            return size;
          }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();
export let ProofLib = /*#__PURE__*/function (ProofLib) {
  ProofLib[ProofLib["Arkworks"] = 0] = "Arkworks";
  ProofLib[ProofLib["Rapidsnark"] = 1] = "Rapidsnark";
  return ProofLib;
}({});
const FfiConverterTypeProofLib = (() => {
  const ordinalConverter = FfiConverterInt32;
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      switch (ordinalConverter.read(from)) {
        case 1:
          return ProofLib.Arkworks;
        case 2:
          return ProofLib.Rapidsnark;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value, into) {
      switch (value) {
        case ProofLib.Arkworks:
          return ordinalConverter.write(1, into);
        case ProofLib.Rapidsnark:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value) {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for Array<ArrayBuffer>
const FfiConverterArrayArrayBuffer = new FfiConverterArray(FfiConverterArrayBuffer);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

// FfiConverter for Map<string, Array<string>>
const FfiConverterMapStringArrayString = new FfiConverterMap(FfiConverterString, FfiConverterArrayString);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion = nativeModule().ubrn_ffi_proofport_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(scaffoldingContractVersion, bindingsContractVersion);
  }
  if (nativeModule().ubrn_uniffi_proofport_checksum_func_combine_proof_and_public_inputs() !== 29030) {
    throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_combine_proof_and_public_inputs");
  }
  if (nativeModule().ubrn_uniffi_proofport_checksum_func_generate_circom_proof() !== 55334) {
    throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_generate_circom_proof");
  }
  if (nativeModule().ubrn_uniffi_proofport_checksum_func_generate_halo2_proof() !== 60458) {
    throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_generate_halo2_proof");
  }
  if (nativeModule().ubrn_uniffi_proofport_checksum_func_generate_noir_proof() !== 7209) {
    throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_generate_noir_proof");
  }
  if (nativeModule().ubrn_uniffi_proofport_checksum_func_get_noir_verification_key() !== 11999) {
    throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_get_noir_verification_key");
  }
  if (nativeModule().ubrn_uniffi_proofport_checksum_func_get_num_public_inputs_from_circuit() !== 28682) {
    throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_get_num_public_inputs_from_circuit");
  }
  if (nativeModule().ubrn_uniffi_proofport_checksum_func_mopro_hello_world() !== 53589) {
    throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_mopro_hello_world");
  }
  if (nativeModule().ubrn_uniffi_proofport_checksum_func_parse_proof_with_public_inputs() !== 41558) {
    throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_parse_proof_with_public_inputs");
  }
  if (nativeModule().ubrn_uniffi_proofport_checksum_func_verify_circom_proof() !== 13690) {
    throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_verify_circom_proof");
  }
  if (nativeModule().ubrn_uniffi_proofport_checksum_func_verify_halo2_proof() !== 34645) {
    throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_verify_halo2_proof");
  }
  if (nativeModule().ubrn_uniffi_proofport_checksum_func_verify_noir_proof() !== 45938) {
    throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_verify_noir_proof");
  }
}
export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeCircomProof,
    FfiConverterTypeCircomProofResult,
    FfiConverterTypeG1,
    FfiConverterTypeG2,
    FfiConverterTypeHalo2ProofResult,
    FfiConverterTypeMoproError,
    FfiConverterTypeProofLib,
    FfiConverterTypeProofWithPublicInputs
  }
});
//# sourceMappingURL=proofport.js.map