// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from "./proofport-ffi";
import {
  type UniffiByteArray, 
  AbstractFfiConverterByteArray, 
  FfiConverterArray, 
  FfiConverterArrayBuffer, 
  FfiConverterBool, 
  FfiConverterInt32, 
  FfiConverterMap, 
  FfiConverterOptional, 
  FfiConverterUInt32, 
  RustBuffer, 
  UniffiError, 
  UniffiInternalError, 
  UniffiRustCaller, 
  uniffiCreateFfiConverterString, 
  uniffiCreateRecord, 
  uniffiTypeNameSymbol, 
  variantOrdinalSymbol } from "uniffi-bindgen-react-native";

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== "object" ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== "production" ||
  false;
// Public interface members begin here.

/**
 * Combine proof and public inputs back into a single proof
 * Used when you need to reconstruct the combined format
 */
export function combineProofAndPublicInputs(proof: ArrayBuffer, publicInputs: Array<ArrayBuffer>): ArrayBuffer {
    return FfiConverterArrayBuffer.lift(uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_proofport_fn_func_combine_proof_and_public_inputs(
        FfiConverterArrayBuffer.lower(proof),
        FfiConverterArrayArrayBuffer.lower(publicInputs),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
export function generateCircomProof(zkeyPath: string, circuitInputs: string, proofLib: ProofLib): CircomProofResult /*throws*/ {
    return FfiConverterTypeCircomProofResult.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeMoproError.lift.bind(FfiConverterTypeMoproError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_proofport_fn_func_generate_circom_proof(
        FfiConverterString.lower(zkeyPath),
        FfiConverterString.lower(circuitInputs),
        FfiConverterTypeProofLib.lower(proofLib),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
export function generateHalo2Proof(srsPath: string, pkPath: string, circuitInputs: Map<string, Array<string>>): Halo2ProofResult /*throws*/ {
    return FfiConverterTypeHalo2ProofResult.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeMoproError.lift.bind(FfiConverterTypeMoproError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_proofport_fn_func_generate_halo2_proof(
        FfiConverterString.lower(srsPath),
        FfiConverterString.lower(pkPath),
        FfiConverterMapStringArrayString.lower(circuitInputs),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
/**
 * Generates a Noir proof with automatic hash function selection
 *
 * This is the main proof generation function that automatically chooses
 * the appropriate hash function based on the intended use case:
 *
 * - `on_chain = true`: Uses Keccak hash for Solidity verifier compatibility
 * - `on_chain = false`: Uses Poseidon hash for better performance
 */
export function generateNoirProof(circuitPath: string, srsPath: string | undefined, inputs: Array<string>, onChain: boolean, vk: ArrayBuffer, lowMemoryMode: boolean): ArrayBuffer /*throws*/ {
    return FfiConverterArrayBuffer.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeMoproError.lift.bind(FfiConverterTypeMoproError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_proofport_fn_func_generate_noir_proof(
        FfiConverterString.lower(circuitPath),
        FfiConverterOptionalString.lower(srsPath),
        FfiConverterArrayString.lower(inputs),
        FfiConverterBool.lower(onChain),
        FfiConverterArrayBuffer.lower(vk),
        FfiConverterBool.lower(lowMemoryMode),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
/**
 * Generates a verification key with automatic hash function selection
 *
 * This function automatically chooses the appropriate hash function based
 * on the intended use case:
 *
 * - `on_chain = true`: Uses Keccak hash for Solidity verifier compatibility
 * - `on_chain = false`: Uses Poseidon hash fotr better performance
 */
export function getNoirVerificationKey(circuitPath: string, srsPath: string | undefined, onChain: boolean, lowMemoryMode: boolean): ArrayBuffer /*throws*/ {
    return FfiConverterArrayBuffer.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeMoproError.lift.bind(FfiConverterTypeMoproError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_proofport_fn_func_get_noir_verification_key(
        FfiConverterString.lower(circuitPath),
        FfiConverterOptionalString.lower(srsPath),
        FfiConverterBool.lower(onChain),
        FfiConverterBool.lower(lowMemoryMode),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
/**
 * Get the number of public inputs from a circuit's JSON manifest
 * This reads the circuit bytecode and extracts the public parameter count
 */
export function getNumPublicInputsFromCircuit(circuitPath: string): /*u32*/number {
    return FfiConverterUInt32.lift(uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_proofport_fn_func_get_num_public_inputs_from_circuit(
        FfiConverterString.lower(circuitPath),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
/**
 * You can also customize the bindings by #[uniffi::export]
 * Reference: https://mozilla.github.io/uniffi-rs/latest/proc_macro/index.html
 */
export function moproHelloWorld(): string {
    return FfiConverterString.lift(uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_proofport_fn_func_mopro_hello_world(
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
/**
 * Parse a combined proof (proof + public inputs) into separated components
 * The mopro proof format has public inputs prepended to the proof bytes
 * This function separates them for on-chain verification
 */
export function parseProofWithPublicInputs(proof: ArrayBuffer, numPublicInputs: /*u32*/number): ProofWithPublicInputs {
    return FfiConverterTypeProofWithPublicInputs.lift(uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_proofport_fn_func_parse_proof_with_public_inputs(
        FfiConverterArrayBuffer.lower(proof),
        FfiConverterUInt32.lower(numPublicInputs),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
export function verifyCircomProof(zkeyPath: string, proofResult: CircomProofResult, proofLib: ProofLib): boolean /*throws*/ {
    return FfiConverterBool.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeMoproError.lift.bind(FfiConverterTypeMoproError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_proofport_fn_func_verify_circom_proof(
        FfiConverterString.lower(zkeyPath),
        FfiConverterTypeCircomProofResult.lower(proofResult),
        FfiConverterTypeProofLib.lower(proofLib),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
export function verifyHalo2Proof(srsPath: string, vkPath: string, proof: ArrayBuffer, publicInput: ArrayBuffer): boolean /*throws*/ {
    return FfiConverterBool.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeMoproError.lift.bind(FfiConverterTypeMoproError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_proofport_fn_func_verify_halo2_proof(
        FfiConverterString.lower(srsPath),
        FfiConverterString.lower(vkPath),
        FfiConverterArrayBuffer.lower(proof),
        FfiConverterArrayBuffer.lower(publicInput),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
/**
 * Verifies a Noir proof with automatic hash function selection
 *
 * This function automatically uses the correct verification method based
 * on how the proof was generated:
 *
 * - `on_chain = true`: Verifies Keccak-based proof (Solidity compatible)
 * - `on_chain = false`: Verifies Poseidon-based proof (performance optimized)
 */
export function verifyNoirProof(circuitPath: string, proof: ArrayBuffer, onChain: boolean, vk: ArrayBuffer, lowMemoryMode: boolean): boolean /*throws*/ {
    return FfiConverterBool.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeMoproError.lift.bind(FfiConverterTypeMoproError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_proofport_fn_func_verify_noir_proof(
        FfiConverterString.lower(circuitPath),
        FfiConverterArrayBuffer.lower(proof),
        FfiConverterBool.lower(onChain),
        FfiConverterArrayBuffer.lower(vk),
        FfiConverterBool.lower(lowMemoryMode),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }








export type CircomProof = {
    a: G1,
    b: G2,
    c: G1,
    protocol: string,
    curve: string
}

/**
 * Generated factory for {@link CircomProof} record objects.
 */
export const CircomProof = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<CircomProof, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link CircomProof}, with defaults specified
         * in Rust, in the {@link proofport} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link CircomProof}, with defaults specified
         * in Rust, in the {@link proofport} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link proofport} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<CircomProof>,
    });
})();

const FfiConverterTypeCircomProof = (() => {
    type TypeName = CircomProof;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                a: FfiConverterTypeG1.read(from), 
                b: FfiConverterTypeG2.read(from), 
                c: FfiConverterTypeG1.read(from), 
                protocol: FfiConverterString.read(from), 
                curve: FfiConverterString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeG1.write(value.a, into);
            FfiConverterTypeG2.write(value.b, into);
            FfiConverterTypeG1.write(value.c, into);
            FfiConverterString.write(value.protocol, into);
            FfiConverterString.write(value.curve, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeG1.allocationSize(value.a) + 
            FfiConverterTypeG2.allocationSize(value.b) + 
            FfiConverterTypeG1.allocationSize(value.c) + 
            FfiConverterString.allocationSize(value.protocol) + 
            FfiConverterString.allocationSize(value.curve);
            
        }
    };
    return new FFIConverter();
})();


export type CircomProofResult = {
    proof: CircomProof,
    inputs: Array<string>
}

/**
 * Generated factory for {@link CircomProofResult} record objects.
 */
export const CircomProofResult = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<CircomProofResult, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link CircomProofResult}, with defaults specified
         * in Rust, in the {@link proofport} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link CircomProofResult}, with defaults specified
         * in Rust, in the {@link proofport} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link proofport} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<CircomProofResult>,
    });
})();

const FfiConverterTypeCircomProofResult = (() => {
    type TypeName = CircomProofResult;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                proof: FfiConverterTypeCircomProof.read(from), 
                inputs: FfiConverterArrayString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeCircomProof.write(value.proof, into);
            FfiConverterArrayString.write(value.inputs, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeCircomProof.allocationSize(value.proof) + 
            FfiConverterArrayString.allocationSize(value.inputs);
            
        }
    };
    return new FFIConverter();
})();


export type G1 = {
    x: string,
    y: string,
    z: string
}

/**
 * Generated factory for {@link G1} record objects.
 */
export const G1 = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<G1, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link G1}, with defaults specified
         * in Rust, in the {@link proofport} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link G1}, with defaults specified
         * in Rust, in the {@link proofport} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link proofport} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<G1>,
    });
})();

const FfiConverterTypeG1 = (() => {
    type TypeName = G1;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                x: FfiConverterString.read(from), 
                y: FfiConverterString.read(from), 
                z: FfiConverterString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.x, into);
            FfiConverterString.write(value.y, into);
            FfiConverterString.write(value.z, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.x) + 
            FfiConverterString.allocationSize(value.y) + 
            FfiConverterString.allocationSize(value.z);
            
        }
    };
    return new FFIConverter();
})();


export type G2 = {
    x: Array<string>,
    y: Array<string>,
    z: Array<string>
}

/**
 * Generated factory for {@link G2} record objects.
 */
export const G2 = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<G2, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link G2}, with defaults specified
         * in Rust, in the {@link proofport} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link G2}, with defaults specified
         * in Rust, in the {@link proofport} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link proofport} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<G2>,
    });
})();

const FfiConverterTypeG2 = (() => {
    type TypeName = G2;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                x: FfiConverterArrayString.read(from), 
                y: FfiConverterArrayString.read(from), 
                z: FfiConverterArrayString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayString.write(value.x, into);
            FfiConverterArrayString.write(value.y, into);
            FfiConverterArrayString.write(value.z, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayString.allocationSize(value.x) + 
            FfiConverterArrayString.allocationSize(value.y) + 
            FfiConverterArrayString.allocationSize(value.z);
            
        }
    };
    return new FFIConverter();
})();


export type Halo2ProofResult = {
    proof: ArrayBuffer,
    inputs: ArrayBuffer
}

/**
 * Generated factory for {@link Halo2ProofResult} record objects.
 */
export const Halo2ProofResult = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Halo2ProofResult, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Halo2ProofResult}, with defaults specified
         * in Rust, in the {@link proofport} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Halo2ProofResult}, with defaults specified
         * in Rust, in the {@link proofport} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link proofport} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Halo2ProofResult>,
    });
})();

const FfiConverterTypeHalo2ProofResult = (() => {
    type TypeName = Halo2ProofResult;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                proof: FfiConverterArrayBuffer.read(from), 
                inputs: FfiConverterArrayBuffer.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayBuffer.write(value.proof, into);
            FfiConverterArrayBuffer.write(value.inputs, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayBuffer.allocationSize(value.proof) + 
            FfiConverterArrayBuffer.allocationSize(value.inputs);
            
        }
    };
    return new FFIConverter();
})();


/**
 * Struct representing a proof with separated public inputs
 * Used for on-chain verification where proof and public inputs are passed separately
 */
export type ProofWithPublicInputs = {
    /**
     * The proof without public inputs (for Solidity verifier)
     */
    proof: ArrayBuffer,
    /**
     * The public inputs as an array of 32-byte values (for Solidity verifier)
     */
    publicInputs: Array<ArrayBuffer>,
    /**
     * The number of public inputs
     */
    numPublicInputs: /*u32*/number
}

/**
 * Generated factory for {@link ProofWithPublicInputs} record objects.
 */
export const ProofWithPublicInputs = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<ProofWithPublicInputs, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link ProofWithPublicInputs}, with defaults specified
         * in Rust, in the {@link proofport} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link ProofWithPublicInputs}, with defaults specified
         * in Rust, in the {@link proofport} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link proofport} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<ProofWithPublicInputs>,
    });
})();

const FfiConverterTypeProofWithPublicInputs = (() => {
    type TypeName = ProofWithPublicInputs;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                proof: FfiConverterArrayBuffer.read(from), 
                publicInputs: FfiConverterArrayArrayBuffer.read(from), 
                numPublicInputs: FfiConverterUInt32.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterArrayBuffer.write(value.proof, into);
            FfiConverterArrayArrayBuffer.write(value.publicInputs, into);
            FfiConverterUInt32.write(value.numPublicInputs, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterArrayBuffer.allocationSize(value.proof) + 
            FfiConverterArrayArrayBuffer.allocationSize(value.publicInputs) + 
            FfiConverterUInt32.allocationSize(value.numPublicInputs);
            
        }
    };
    return new FFIConverter();
})();


const stringConverter = {
    stringToBytes: (s: string) =>
        uniffiCaller.rustCall((status) => nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(s, status)),
    bytesToString: (ab: UniffiByteArray) =>
        uniffiCaller.rustCall((status) => nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(ab, status)),
    stringByteLength: (s: string) =>
        uniffiCaller.rustCall((status) => nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(s, status)),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);




// Error type: MoproError

// Enum: MoproError
export enum MoproError_Tags {
    CircomError = "CircomError",
    Halo2Error = "Halo2Error",
    NoirError = "NoirError"
}
export const MoproError = (() => {
    

    type CircomError__interface = {
        tag: MoproError_Tags.CircomError;
        inner: Readonly<
[string
]>
    };

    
    class CircomError_ extends UniffiError implements CircomError__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "MoproError";
        readonly tag = MoproError_Tags.CircomError;
        readonly inner: Readonly<
[string
]>;
        constructor(v0: string) {
            super("MoproError", "CircomError");
            this.inner = Object.freeze([v0]);
        }

        static new(v0: string): CircomError_ {
            return new CircomError_(v0);
        }

        static instanceOf(obj: any): obj is CircomError_ {
            return obj.tag === MoproError_Tags.CircomError;
        }

        
        static hasInner(obj: any): obj is CircomError_ {
            return CircomError_.instanceOf(obj);
        }

        static getInner(obj: CircomError_): Readonly<
[string
]> {
            return obj.inner;
        }

    }
    

    type Halo2Error__interface = {
        tag: MoproError_Tags.Halo2Error;
        inner: Readonly<
[string
]>
    };

    
    class Halo2Error_ extends UniffiError implements Halo2Error__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "MoproError";
        readonly tag = MoproError_Tags.Halo2Error;
        readonly inner: Readonly<
[string
]>;
        constructor(v0: string) {
            super("MoproError", "Halo2Error");
            this.inner = Object.freeze([v0]);
        }

        static new(v0: string): Halo2Error_ {
            return new Halo2Error_(v0);
        }

        static instanceOf(obj: any): obj is Halo2Error_ {
            return obj.tag === MoproError_Tags.Halo2Error;
        }

        
        static hasInner(obj: any): obj is Halo2Error_ {
            return Halo2Error_.instanceOf(obj);
        }

        static getInner(obj: Halo2Error_): Readonly<
[string
]> {
            return obj.inner;
        }

    }
    

    type NoirError__interface = {
        tag: MoproError_Tags.NoirError;
        inner: Readonly<
[string
]>
    };

    
    class NoirError_ extends UniffiError implements NoirError__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "MoproError";
        readonly tag = MoproError_Tags.NoirError;
        readonly inner: Readonly<
[string
]>;
        constructor(v0: string) {
            super("MoproError", "NoirError");
            this.inner = Object.freeze([v0]);
        }

        static new(v0: string): NoirError_ {
            return new NoirError_(v0);
        }

        static instanceOf(obj: any): obj is NoirError_ {
            return obj.tag === MoproError_Tags.NoirError;
        }

        
        static hasInner(obj: any): obj is NoirError_ {
            return NoirError_.instanceOf(obj);
        }

        static getInner(obj: NoirError_): Readonly<
[string
]> {
            return obj.inner;
        }

    }

    function instanceOf(obj: any): obj is MoproError {
        return obj[uniffiTypeNameSymbol] === "MoproError";
    }

    return Object.freeze({
        instanceOf,
  CircomError: CircomError_, 
  Halo2Error: Halo2Error_, 
  NoirError: NoirError_
    });

})();



export type MoproError = InstanceType<
    typeof MoproError[keyof Omit<typeof MoproError, 'instanceOf'>]
>;

// FfiConverter for enum MoproError
const FfiConverterTypeMoproError = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = MoproError;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return new MoproError.CircomError(FfiConverterString.read(from));
                case 2: return new MoproError.Halo2Error(FfiConverterString.read(from));
                case 3: return new MoproError.NoirError(FfiConverterString.read(from));
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value.tag) {
                case MoproError_Tags.CircomError: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner[0], into);
                    return;
                }
                case MoproError_Tags.Halo2Error: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner[0], into);
                    return;
                }
                case MoproError_Tags.NoirError: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner[0], into);
                    return;
                }
                default:
                    // Throwing from here means that MoproError_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value: TypeName): number {
            switch (value.tag) {
                case MoproError_Tags.CircomError: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterString.allocationSize(inner[0]);
                    return size;
                }
                case MoproError_Tags.Halo2Error: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner[0]);
                    return size;
                }
                case MoproError_Tags.NoirError: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner[0]);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();


export enum ProofLib {
    Arkworks,
    Rapidsnark
}

const FfiConverterTypeProofLib = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = ProofLib;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return ProofLib.Arkworks;
                case 2: return ProofLib.Rapidsnark;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value) {
                case ProofLib.Arkworks: return ordinalConverter.write(1, into);
                case ProofLib.Rapidsnark: return ordinalConverter.write(2, into);
            }
        }
        allocationSize(value: TypeName): number {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();





// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);


// FfiConverter for Array<ArrayBuffer>
const FfiConverterArrayArrayBuffer = new FfiConverterArray(FfiConverterArrayBuffer);


// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);


// FfiConverter for Map<string, Array<string>>
const FfiConverterMapStringArrayString = new FfiConverterMap(FfiConverterString, FfiConverterArrayString);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
    // Get the bindings contract version from our ComponentInterface
    const bindingsContractVersion = 29;
    // Get the scaffolding contract version by calling the into the dylib
    const scaffoldingContractVersion = nativeModule().ubrn_ffi_proofport_uniffi_contract_version();
    if (bindingsContractVersion !== scaffoldingContractVersion) {
        throw new UniffiInternalError.ContractVersionMismatch(scaffoldingContractVersion, bindingsContractVersion);
    }
    if (nativeModule().ubrn_uniffi_proofport_checksum_func_combine_proof_and_public_inputs() !== 29030) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_combine_proof_and_public_inputs");
    }
    if (nativeModule().ubrn_uniffi_proofport_checksum_func_generate_circom_proof() !== 55334) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_generate_circom_proof");
    }
    if (nativeModule().ubrn_uniffi_proofport_checksum_func_generate_halo2_proof() !== 60458) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_generate_halo2_proof");
    }
    if (nativeModule().ubrn_uniffi_proofport_checksum_func_generate_noir_proof() !== 7209) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_generate_noir_proof");
    }
    if (nativeModule().ubrn_uniffi_proofport_checksum_func_get_noir_verification_key() !== 11999) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_get_noir_verification_key");
    }
    if (nativeModule().ubrn_uniffi_proofport_checksum_func_get_num_public_inputs_from_circuit() !== 28682) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_get_num_public_inputs_from_circuit");
    }
    if (nativeModule().ubrn_uniffi_proofport_checksum_func_mopro_hello_world() !== 53589) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_mopro_hello_world");
    }
    if (nativeModule().ubrn_uniffi_proofport_checksum_func_parse_proof_with_public_inputs() !== 41558) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_parse_proof_with_public_inputs");
    }
    if (nativeModule().ubrn_uniffi_proofport_checksum_func_verify_circom_proof() !== 13690) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_verify_circom_proof");
    }
    if (nativeModule().ubrn_uniffi_proofport_checksum_func_verify_halo2_proof() !== 34645) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_verify_halo2_proof");
    }
    if (nativeModule().ubrn_uniffi_proofport_checksum_func_verify_noir_proof() !== 45938) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_proofport_checksum_func_verify_noir_proof");
    }

    }

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeCircomProof,
    FfiConverterTypeCircomProofResult,
    FfiConverterTypeG1,
    FfiConverterTypeG2,
    FfiConverterTypeHalo2ProofResult,
    FfiConverterTypeMoproError,
    FfiConverterTypeProofLib,
    FfiConverterTypeProofWithPublicInputs,
  }
});